use std::{collections::HashMap};



use crate::{
    lexer::{Token, TokenStream},
    types::SculkType,
};

#[derive(Clone, Copy, Debug)]
pub enum Operation {
    Add,
    Subtract,
    Multiply,
    Divide,
    Modulo,
    GreaterThan,
    LessThan,
    GreaterThanOrEquals,
    LessThanOrEquals,
    CheckEquals,
    NotEquals,
    Not,
    Negate,
}

#[derive(Clone, Debug)]
pub enum ParserNode {
    Program(Vec<ParserNode>),
    Block(Vec<ParserNode>),
    NumberLiteral(i32),
    BoolLiteral(bool),
    SelectorLiteral(SelectorTarget),
    Identifier(String),
    TypedIdentifier {
        name: String,
        ty: SculkType,
    },
    VariableDeclaration {
        name: String,
        expr: Box<ParserNode>,
        ty: Option<SculkType>,
    },
    VariableAssignment {
        name: String,
        expr: Box<ParserNode>,
    },
    FunctionDeclaration {
        name: String,
        args: Vec<ParserNode>,
        return_ty: SculkType,
        body: Box<ParserNode>,
    },
    Return(Box<ParserNode>),
    FunctionCall {
        name: String,
        args: Vec<ParserNode>,
    },
    Operation(Box<ParserNode>, Box<ParserNode>, Operation),
    OpEquals {
        name: String,
        expr: Box<ParserNode>,
        op: Operation,
    },
    Unary(Box<ParserNode>, Operation),
    If {
        // see rebranch::rebranch
        cond: Box<ParserNode>,
        body: Box<ParserNode>,
        else_ifs: Vec<(ParserNode, ParserNode)>,
        else_body: Option<Box<ParserNode>>,
    },
    ReturnSafe(Box<ParserNode>), // not parsed, but generated by the rebrancher
}

impl ParserNode {
    pub fn is_num(&self) -> bool {
        match self {
            Self::NumberLiteral(_) => true,
            _ => false,
        }
    }

    fn as_num(&self) -> i32 {
        match self {
            Self::NumberLiteral(num) => *num,
            _ => panic!("tried to get number from non-number node"),
        }
    }

    pub fn as_identifier(&self) -> &str {
        match self {
            Self::Identifier(name) => name,
            Self::TypedIdentifier { name, .. } => name,
            _ => panic!("tried to get identifier from non-identifier node"),
        }
    }

    pub fn as_type(&self) -> SculkType {
        match self {
            Self::TypedIdentifier { ty, .. } => ty.clone(),
            _ => panic!("tried to get type from non-typed identifier node"),
        }
    }
}

macro_rules! expect_tok {
    ($parser:expr, $token:pat, $err:expr) => {
        match $parser.tokens.peek() {
            Some($token) => $parser.tokens.next(),
            _ => return $parser.error($err),
        };
    };
}

pub struct Parser<'a> {
    tokens: TokenStream<'a>,
    errors: Vec<ParseError>,
    func_defs: HashMap<String, FunctionDefinition>,
}

impl<'a> Parser<'a> {
    pub fn new(src: &'a str) -> Self {
        Self {
            tokens: TokenStream::new(src),
            errors: Vec::new(),
            func_defs: HashMap::new(),
        }
    }

    pub fn parse(mut self) -> ParserOutput {
        let mut functions = Vec::new();

        while self.tokens.peek().is_some() {
            match self.parse_func_declaration() {
                Ok(stmt) => functions.push(stmt),
                Err(_) => break, // error already logged, continue parsing
            };
        }

        ParserOutput::new(ParserNode::Program(functions), self.func_defs, self.errors)
    }

    fn parse_block(&mut self) -> ParseResult {
        expect_tok!(self, Token::LeftBrace, "expected {");

        let mut statements = Vec::new();

        while self.tokens.peek() != Some(&Token::RightBrace) {
            statements.push(self.parse_statement()?);
        }

        expect_tok!(self, Token::RightBrace, "expected }");

        Ok(ParserNode::Block(statements))
    }

    fn parse_statement(&mut self) -> ParseResult {
        match self.tokens.peek() {
            Some(Token::Let) => self.parse_var_declaration(),
            Some(Token::Fn) => self.parse_func_declaration(),
            Some(Token::If) => self.parse_if(),
            Some(Token::LeftBrace) => self.parse_block(),
            Some(Token::Return) => self.parse_return_statement(),
            Some(Token::Identifier(_)) => {
                let ident = self.parse_identifier()?.as_identifier().to_string();

                match self.tokens.peek() {
                    Some(Token::Equals) => self.parse_var_assignment(ident),
                    Some(Token::LeftParens) => self.parse_func_call(ident),
                    Some(Token::AddEquals) | Some(Token::SubtractEquals) | Some(Token::MultiplyEquals) | Some(Token::DivideEquals) | Some(Token::ModuloEquals) => {
                        self.parse_op_equals(ident)
                    }
                    _ => self.error("expected statement"),
                }
            },
            _ => self.error("expected statement"),
        }
    }

    fn parse_var_declaration(&mut self) -> ParseResult {
        expect_tok!(self, Token::Let, "expected let");

        let identifier = self.parse_typed_identifier(true)?;

        expect_tok!(self, Token::Equals, "expected =");

        let expr = self.parse_expression()?;

        expect_tok!(self, Token::Semicolon, "expected ;");

        match identifier {
            ParserNode::TypedIdentifier { name, ty } => Ok(ParserNode::VariableDeclaration {
                name,
                expr: Box::new(expr),
                ty: Some(ty),
            }),
            ParserNode::Identifier(name) => Ok(ParserNode::VariableDeclaration {
                name,
                expr: Box::new(expr),
                ty: None,
            }),
            _ => self.error("expected identifier"),
        }
    }

    fn parse_var_assignment(&mut self, name: String) -> ParseResult {
        expect_tok!(self, Token::Equals, "expected =");

        let expr = self.parse_expression()?;

        expect_tok!(self, Token::Semicolon, "expected ;");

        Ok(ParserNode::VariableAssignment {
            name,
            expr: Box::new(expr),
        })
    }

    fn parse_func_declaration(&mut self) -> ParseResult {
        expect_tok!(self, Token::Fn, "expected fn");

        let name = self.parse_identifier()?;

        expect_tok!(self, Token::LeftParens, "expected (");

        let mut args = Vec::new();

        if self.tokens.peek() != Some(&Token::RightParens) {
            let arg = self.parse_typed_identifier(false)?;
            args.push(arg);

            while self.tokens.peek() == Some(&Token::Comma) {
                self.tokens.next(); // consume the comma
                let arg = self.parse_typed_identifier(false)?;
                args.push(arg);
            }
        }

        expect_tok!(self, Token::RightParens, "expected )");

        let return_ty = match self.tokens.peek() {
            Some(Token::Arrow) => {
                self.tokens.next(); // consume the arrow
                let return_ty = self.parse_identifier()?;
                str_to_type(return_ty.as_identifier())
            }
            _ => SculkType::None,
        };

        let body = self.parse_block()?;

        let name = name.as_identifier().to_string();
        self.func_defs.insert(
            name.clone(),
            FunctionDefinition {
                name: name.clone(),
                args: args
                    .iter()
                    .map(|arg| arg.as_identifier().to_string())
                    .collect(),
            },
        );

        Ok(ParserNode::FunctionDeclaration {
            name: name.clone(),
            args,
            return_ty,
            body: Box::new(body),
        })
    }

    fn parse_return_statement(&mut self) -> ParseResult {
        expect_tok!(self, Token::Return, "expected return");

        let expr = self.parse_expression()?;

        expect_tok!(self, Token::Semicolon, "expected ;");

        Ok(ParserNode::Return(Box::new(expr)))
    }

    fn parse_func_call(&mut self, name: String) -> ParseResult {
        expect_tok!(self, Token::LeftParens, "expected (");

        let mut args = Vec::new();

        if self.tokens.peek() != Some(&Token::RightParens) {
            let arg = self.parse_expression()?;
            args.push(arg);

            while self.tokens.peek() == Some(&Token::Comma) {
                self.tokens.next(); // consume the comma
                let arg = self.parse_expression()?;
                args.push(arg);
            }
        }

        expect_tok!(self, Token::RightParens, "expected )");

        Ok(ParserNode::FunctionCall { name, args })
    }

    fn parse_if(&mut self) -> ParseResult {
        expect_tok!(self, Token::If, "expected if");

        let cond = self.parse_expression()?;
        let body = self.parse_block()?;

        let mut else_ifs = Vec::new();
        let mut else_body = None;

        while self.tokens.peek() == Some(&Token::Else) {
            self.tokens.next(); // consume the else

            if self.tokens.peek() == Some(&Token::If) {
                self.tokens.next(); // consume the if
                let cond = self.parse_expression()?;
                let body = self.parse_block()?;

                else_ifs.push((cond, body));
            } else {
                else_body = Some(self.parse_block()?);
                break;
            }
        }

        Ok(ParserNode::If {
            cond: Box::new(cond),
            body: Box::new(body),
            else_ifs,
            else_body: else_body.map(Box::new),
        })
    }

    fn parse_expression_statement(&mut self) -> ParseResult {
        let expr = self.parse_expression()?;
        expect_tok!(self, Token::Semicolon, "expected ;");
        Ok(expr)
    }

    fn parse_expression(&mut self) -> ParseResult {
        self.parse_equality()
    }

    fn parse_number(&mut self) -> ParseResult {
        let tok = self.tokens.next();

        match tok {
            Some(Token::Number(n)) => Ok(ParserNode::NumberLiteral(*n)),
            _ => self.error("expected number"),
        }
    }

    fn parse_bool(&mut self) -> ParseResult {
        let tok = self.tokens.next();

        match tok {
            Some(Token::Bool(b)) => Ok(ParserNode::BoolLiteral(*b)),
            _ => self.error("expected bool"),
        }
    }

    fn parse_selector(&mut self) -> ParseResult {
        let tok = self.tokens.next();

        match tok {
            Some(Token::Selector(target)) => Ok(ParserNode::SelectorLiteral(match target {
                'a' => SelectorTarget::AllPlayers,
                'p' => SelectorTarget::NearestPlayer,
                'r' => SelectorTarget::RandomPlayer,
                'e' => SelectorTarget::AllEntities,
                's' => SelectorTarget::ExecutingEntity,
                _ => unreachable!(),
            })),
            _ => self.error("expected selector"),
        }
    }

    fn parse_identifier(&mut self) -> ParseResult {
        let tok = self.tokens.next();

        match tok {
            Some(Token::Identifier(identifier)) => Ok(ParserNode::Identifier(identifier.clone())),
            _ => self.error("expected identifier"),
        }
    }

    fn parse_primary(&mut self) -> ParseResult {
        match self.tokens.peek() {
            Some(Token::Number(_)) => self.parse_number(),
            Some(Token::Bool(_)) => self.parse_bool(),
            Some(Token::Identifier(_)) => {
                let identifier = self.parse_identifier()?;

                match self.tokens.peek() {
                    Some(Token::LeftParens) => {
                        self.parse_func_call(identifier.as_identifier().to_string())
                    }
                    _ => Ok(identifier),
                }
            }
            Some(Token::Selector(_)) => self.parse_selector(),
            Some(Token::LeftParens) => {
                self.tokens.next();
                let expr = self.parse_term();

                match self.tokens.next() {
                    Some(Token::RightParens) => expr,
                    _ => self.error("expected ) after expression"),
                }
            }
            _ => self.error("expected value or expression"),
        }
    }

    fn parse_unary(&mut self) -> ParseResult {
        let op = match self.tokens.peek() {
            Some(Token::Subtract) => Operation::Negate,
            Some(Token::Not) => Operation::Not,
            _ => return self.parse_primary(),
        };

        self.tokens.next();

        let expr = self.parse_unary()?;

        Ok(ParserNode::Unary(Box::new(expr), op))
    }

    // does not necessarily parse an equality, but rather an equality or a comparison (and in turn a comparison or a term)
    fn parse_equality(&mut self) -> ParseResult {
        let mut expr = self.parse_comparison()?;

        while self.tokens.peek().is_some() {
            let op = match self.tokens.peek().unwrap() {
                Token::EqualsEquals => Operation::CheckEquals,
                Token::NotEquals => Operation::NotEquals,
                _ => break,
            };

            self.tokens.next();

            let comparison = self.parse_comparison()?;
            expr = ParserNode::Operation(Box::new(expr), Box::new(comparison), op);
        }

        Ok(expr)
    }

    // does not necessarily parse a comparison, but rather a comparison or a term
    // TODO: stop multiple inequalities in the same expression
    fn parse_comparison(&mut self) -> ParseResult {
        let mut expr = self.parse_term()?;

        while self.tokens.peek().is_some() {
            let op = match self.tokens.peek().unwrap() {
                Token::LessThan => Operation::LessThan,
                Token::LessThanOrEquals => Operation::LessThanOrEquals,
                Token::GreaterThan => Operation::GreaterThan,
                Token::GreaterThanOrEquals => Operation::GreaterThanOrEquals,
                _ => break,
            };

            self.tokens.next();

            let term = self.parse_term()?;
            expr = ParserNode::Operation(Box::new(expr), Box::new(term), op);
        }

        Ok(expr)
    }

    fn parse_term(&mut self) -> ParseResult {
        let mut expr = self.parse_factor()?;

        while self.tokens.peek().is_some() {
            let op = match self.tokens.peek().unwrap() {
                Token::Add => Operation::Add,
                Token::Subtract => Operation::Subtract,
                _ => break,
            };

            self.tokens.next();

            let term = self.parse_factor()?;
            expr = ParserNode::Operation(Box::new(expr), Box::new(term), op);
        }

        Ok(expr)
    }

    fn parse_factor(&mut self) -> ParseResult {
        let mut expr = self.parse_unary()?;

        while self.tokens.peek().is_some() {
            let op = match self.tokens.peek().unwrap() {
                Token::Multiply => Operation::Multiply,
                Token::Divide => Operation::Divide,
                Token::Modulo => Operation::Modulo,
                _ => break,
            };

            self.tokens.next();

            let term = self.parse_unary()?;
            expr = ParserNode::Operation(Box::new(expr), Box::new(term), op);
        }

        Ok(expr)
    }

    fn parse_op_equals(&mut self, name: String) -> ParseResult {
        let op = match self.tokens.next() {
            Some(Token::AddEquals) => Operation::Add,
            Some(Token::SubtractEquals) => Operation::Subtract,
            Some(Token::MultiplyEquals) => Operation::Multiply,
            Some(Token::DivideEquals) => Operation::Divide,
            Some(Token::ModuloEquals) => Operation::Modulo,
            _ => unreachable!(),
        };

        let expr = self.parse_expression()?;

        expect_tok!(self, Token::Semicolon, "expected ; after expression");

        Ok(ParserNode::OpEquals { name, expr: Box::new(expr), op })
    }

    fn parse_typed_identifier(&mut self, ty_optional: bool) -> ParseResult {
        let name = match self.parse_identifier()? {
            ParserNode::Identifier(identifier) => identifier,
            _ => unreachable!(),
        };

        if ty_optional && self.tokens.peek() != Some(&Token::Colon) {
            return Ok(ParserNode::Identifier(name));
        }

        expect_tok!(self, Token::Colon, "expected :");

        let ty = match self.tokens.next() {
            Some(Token::Identifier(name)) => str_to_type(name),
            _ => return self.error("expected valid type"),
        };

        Ok(ParserNode::TypedIdentifier { name, ty })
    }

    fn error(&mut self, error: impl Into<String>) -> ParseResult {
        let error = ParseError::new(error, self.tokens.line(), self.tokens.col());
        self.errors.push(error);
        self.recover();
        Err(())
    }

    pub fn errors(&self) -> &[ParseError] {
        &self.errors
    }

    // try to recover from an error by jumping to the next statement
    fn recover(&mut self) {
        while self.tokens.peek().is_some() {
            match self.tokens.peek().unwrap() {
                Token::Semicolon => {
                    self.tokens.next();
                    return;
                }
                Token::Let => return,
                _ => self.tokens.next(),
            };
        }
    }
}

fn str_to_type(name: &str) -> SculkType {
    match name {
        "int" => SculkType::Integer,
        "bool" => SculkType::Bool,
        "selector" => SculkType::Selector,
        _ => SculkType::Struct(name.to_string()),
    }
}

pub struct ParserOutput {
    pub ast: ParserNode,
    pub func_defs: HashMap<String, FunctionDefinition>,
    pub errs: Vec<ParseError>,
}

impl ParserOutput {
    fn new(
        ast: ParserNode,
        func_defs: HashMap<String, FunctionDefinition>,
        errs: Vec<ParseError>,
    ) -> Self {
        Self {
            ast,
            func_defs,
            errs,
        }
    }
}

pub struct FunctionDefinition {
    pub name: String,
    pub args: Vec<String>,
}

impl FunctionDefinition {
    fn new(name: String, args: Vec<String>) -> Self {
        Self { name, args }
    }
}

type ParseResult = Result<ParserNode, ()>;

#[derive(Clone, Debug)]
pub struct ParseError {
    error: String,
    line: usize,
    col: usize,
}

impl ParseError {
    pub fn new(error: impl Into<String>, line: usize, col: usize) -> Self {
        ParseError {
            error: error.into(),
            line,
            col,
        }
    }
}

// TODO: move out of this file
#[derive(Clone, Copy, Debug)]
pub enum SelectorTarget {
    AllPlayers,
    NearestPlayer,
    RandomPlayer,
    AllEntities,
    ExecutingEntity,
}
